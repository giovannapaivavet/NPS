<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simulador e Projeção de NPS</title>
  <!-- Carrega o Tailwind CSS para o estilo -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Carrega React, ReactDOM e PropTypes (uma nova adição necessária) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!--
    Adicionado explicitamente o PropTypes. A versão 18 do React já não o inclui
    diretamente no bundle do ReactDOM, mas bibliotecas como o Recharts ainda
    dependem dele.
  -->
  <script crossorigin src="https://unpkg.com/prop-types@15.8.1/prop-types.js"></script>
  <!-- Carrega Babel para transformar o JSX -->
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!--
    Corrigido o erro do Recharts. A versão 2.8.0 é usada para garantir a
    compatibilidade com a versão 18 do React, que estava causando o erro de
    tipo e a referência indefinida.
  -->
  <script crossorigin src="https://unpkg.com/recharts@2.8.0/umd/Recharts.js"></script>
  <style>
    /* Estilo para a fonte "Inter" */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    body {
      font-family: 'Inter', sans-serif;
    }
  </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">
  <div id="root"></div>

  <script type="text/babel">
    // Espera que todos os scripts e o DOM estejam carregados antes de iniciar a aplicação React
    window.onload = function() {
      const { useState, useMemo } = React;
      // As componentes Recharts são desestruturadas aqui dentro do onLOAD,
      // garantindo que o objeto global 'Recharts' já está definido e disponível.
      const { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } = Recharts;

      // Componentes recriados do shadcn para evitar erros de importação
      const Card = ({ children, className }) => (
        <div className={`rounded-xl border bg-card text-card-foreground shadow ${className}`}>
          {children}
        </div>
      );

      const CardHeader = ({ children, className }) => (
        <div className={`flex flex-col space-y-1.5 p-6 ${className}`}>
          {children}
        </div>
      );

      const CardTitle = ({ children, className }) => (
        <h3 className={`font-semibold tracking-tight text-2xl ${className}`}>
          {children}
        </h3>
      );

      const CardDescription = ({ children, className }) => (
        <p className={`text-sm text-muted-foreground ${className}`}>
          {children}
        </p>
      );

      const CardContent = ({ children, className }) => (
        <div className={`p-6 pt-0 ${className}`}>
          {children}
        </div>
      );

      const Button = ({ children, className, onClick }) => (
        <button
          className={`inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 h-9 px-4 py-2 ${className}`}
          onClick={onClick}
        >
          {children}
        </button>
      );

      const Input = ({ className, type, value, onChange, ...props }) => (
        <input
          type={type}
          value={value}
          onChange={onChange}
          className={`flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 ${className}`}
          {...props}
        />
      );

      const Label = ({ children, className, htmlFor }) => (
        <label
          htmlFor={htmlFor}
          className={`text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 ${className}`}
        >
          {children}
        </label>
      );

      const Tabs = ({ children, defaultValue }) => {
        const [activeTab, setActiveTab] = useState(defaultValue);
        return (
          <div className="flex flex-col">
            {React.Children.map(children, child =>
              React.cloneElement(child, { activeTab, setActiveTab })
            )}
          </div>
        );
      };

      const TabsList = ({ children, className, activeTab, setActiveTab }) => (
        <div className={`inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground ${className}`}>
          {React.Children.map(children, child =>
            React.cloneElement(child, { activeTab, setActiveTab })
          )}
        </div>
      );

      const TabsTrigger = ({ children, value, className, activeTab, setActiveTab }) => (
        <button
          className={`inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 ${
            activeTab === value ? 'bg-background text-foreground shadow' : ''
          } ${className}`}
          onClick={() => setActiveTab(value)}
        >
          {children}
        </button>
      );

      const TabsContent = ({ children, value, className, activeTab }) => (
        <div className={`mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 ${
          activeTab === value ? '' : 'hidden'
        } ${className}`}>
          {children}
        </div>
      );

      // O componente App é o container principal da nossa aplicação
      const App = () => {
        // Dados iniciais consolidados (promotores, neutros, detratores de voz + whatsapp)
        const initialCombinedData = [
          { month: 'Jan', prom: 973, neutr: 52, detra: 40, isProjected: false },
          { month: 'Fev', prom: 1334, neutr: 61, detra: 28, isProjected: false },
          { month: 'Mar', prom: 1243, neutr: 86, detra: 51, isProjected: false },
          { month: 'Abr', prom: 1396, neutr: 62, detra: 47, isProjected: false },
          { month: 'Mai', prom: 1412, neutr: 48, detra: 44, isProjected: false },
          { month: 'Jun', prom: 975, neutr: 38, detra: 26, isProjected: false },
          { month: 'Jul', prom: 990, neutr: 26, detra: 13, isProjected: false }
        ];

        const allMonths = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
        
        // Projeção automática para meses não preenchidos
        const projectionData = useMemo(() => {
          // Calcula a média dos últimos 4 meses de dados existentes (Abril a Julho)
          const lastFourMonths = initialCombinedData.slice(-4);
          const avgData = lastFourMonths.reduce((acc, curr) => {
            acc.prom += curr.prom;
            acc.neutr += curr.neutr;
            acc.detra += curr.detra;
            return acc;
          }, { prom: 0, neutr: 0, detra: 0 });
        
          const avgProm = Math.round(avgData.prom / lastFourMonths.length);
          const avgNeutr = Math.round(avgData.neutr / lastFourMonths.length);
          const avgDetra = Math.round(avgData.detra / lastFourMonths.length);
        
          // Preenche os meses restantes com a projeção
          const fullData = [...initialCombinedData];
          for (let i = initialCombinedData.length; i < allMonths.length; i++) {
            fullData.push({
              month: allMonths[i],
              prom: avgProm,
              neutr: avgNeutr,
              detra: avgDetra,
              isProjected: true, // Marca como dado projetado
            });
          }
          return fullData;
        }, []);
        
        // Estado para armazenar os dados do simulador, inicializado com a projeção
        const [data, setData] = useState(projectionData);
        // Estado para armazenar o volume total de notas para o cálculo inverso
        const [totalNotas, setTotalNotas] = useState(1000);
        const [inverseResults, setInverseResults] = useState([]);
        const [annualGoalResult, setAnnualGoalResult] = useState(null);
        const [projectedTotalNotes, setProjectedTotalNotes] = useState(1000); // Estado para a projeção de notas

        // Função para calcular o NPS
        const calculateNps = (promoters, detractors, total) => {
          if (total === 0) return 0;
          return parseFloat(((promoters - detractors) / total) * 100).toFixed(1);
        };
        
        // Projeção do NPS CX com base nos dados
        const npsProjectionData = useMemo(() => {
          return data.map(monthData => {
            const totalVolume = monthData.prom + monthData.neutr + monthData.detra;
            const npsCx = calculateNps(monthData.prom, monthData.detra, totalVolume);
            return {
              ...monthData,
              totalVolume,
              npsCx
            };
          });
        }, [data]);
        
        // Handle de alteração nos inputs da projeção
        const handleProjectionChange = (index, type, value) => {
          const newData = [...data];
          newData[index][type] = parseInt(value, 10) || 0;
          setData(newData);
        };
        
        // Handle de cálculo do NPS inverso
        const handleInverseCalculation = () => {
          const targetNps = 95;
          const results = [];
          
          const initialTotalNotes = initialCombinedData.reduce((sum, d) => sum + d.prom + d.neutr + d.detra, 0);
          const initialTotalNeutrals = initialCombinedData.reduce((sum, d) => sum + d.neutr, 0);
          const neutralRatio = initialTotalNeutrals / initialTotalNotes;
        
          for (let i = 0; i < 12; i++) {
            const notes = totalNotas; // Usa o totalNotas do estado
            const neutrals = Math.round(notes * neutralRatio);
        
            // Usando a fórmula NPS = (Promotores - Detratores) / Total * 100
            const equation1 = (targetNps / 100) * notes;
            const equation2 = notes - neutrals;
        
            const promoters = Math.round((equation1 + equation2) / 2);
            const detractors = Math.round((equation2 - equation1) / 2);
        
            results.push({
              month: allMonths[i],
              totalNotas: notes,
              promotores: promoters,
              detratores: detractors,
              neutros: neutrals,
              npsCalculado: calculateNps(promoters, detractors, notes),
            });
          }
          setInverseResults(results);
        };
        
        // Nova função para calcular a meta de NPS 95 para o ano
        const handleAnnualGoalCalculation = () => {
          const monthsPast = initialCombinedData.length;
          const monthsToProject = allMonths.length - monthsPast;
          const annualTargetNps = 95;
        
          // Dados acumulados dos meses fechados
          const pastMetrics = initialCombinedData.reduce((acc, curr) => {
            acc.totalVolume += curr.prom + curr.neutr + curr.detra;
            acc.totalPromoters += curr.prom;
            acc.totalNeutrals += curr.neutr;
            acc.totalDetractors += curr.detra;
            return acc;
          }, { totalVolume: 0, totalPromoters: 0, totalNeutrals: 0, totalDetractors: 0 });
        
          // Projeção do volume total para o ano
          const projectedTotalAnnualVolume = pastMetrics.totalVolume + (monthsToProject * projectedTotalNotes);
          
          // Cálculo do NPS acumulado até o momento
          const currentNps = calculateNps(pastMetrics.totalPromoters, pastMetrics.totalDetractors, pastMetrics.totalVolume);

          // Proporção de neutros com base nos dados fechados
          const neutralRatio = pastMetrics.totalNeutrals / pastMetrics.totalVolume;
          
          // Cálculo da distribuição necessária para atingir a meta anual de 95%
          const targetPromotersDetractorsSum = projectedTotalAnnualVolume - (projectedTotalAnnualVolume * neutralRatio);
          const targetPromotersDetractorsDiff = (annualTargetNps / 100) * projectedTotalAnnualVolume;
          
          const totalPromotersNeeded = Math.round((targetPromotersDetractorsSum + targetPromotersDetractorsDiff) / 2);
          const totalDetractorsNeeded = Math.round((targetPromotersDetractorsSum - targetPromotersDetractorsDiff) / 2);
          const totalNeutralsNeeded = Math.round(projectedTotalAnnualVolume * neutralRatio);
          
          const remainingPromotersNeeded = totalPromotersNeeded - pastMetrics.totalPromoters;
          const remainingDetractorsNeeded = totalDetractorsNeeded - pastMetrics.totalDetractors;
          const remainingNeutralsNeeded = totalNeutralsNeeded - pastMetrics.totalNeutrals;
        
          let isAchievable = true;
          let maxNps = 0;
          
          // Verificar se a meta é alcançável
          if (remainingPromotersNeeded < 0 || remainingDetractorsNeeded < 0 || remainingNeutralsNeeded < 0) {
            isAchievable = false;
            // Se a meta não for alcançável, calculamos o NPS máximo possível
            const maxPossiblePromoters = pastMetrics.totalPromoters + (monthsToProject * (projectedTotalNotes - Math.round(projectedTotalNotes * neutralRatio)));
            const maxPossibleDetractors = pastMetrics.totalDetractors; // Detratores não podem ser negativos
            maxNps = calculateNps(maxPossiblePromoters, maxPossibleDetractors, projectedTotalAnnualVolume);
          }
          
          setAnnualGoalResult({
            isAchievable,
            currentNps,
            projectedTotalAnnualVolume,
            targetNps: annualTargetNps,
            maxNps,
            monthlyPromoters: isAchievable ? Math.round(remainingPromotersNeeded / monthsToProject) : 'N/A',
            monthlyDetractors: isAchievable ? Math.round(remainingDetractorsNeeded / monthsToProject) : 'N/A',
            monthlyNeutrals: isAchievable ? Math.round(remainingNeutralsNeeded / monthsToProject) : 'N/A',
          });
        };
        

        return (
          <div className="p-4 md:p-8 bg-gray-100 min-h-screen font-sans">
            <Card className="max-w-7xl mx-auto rounded-xl shadow-lg">
              <CardHeader className="bg-red-800 text-white rounded-t-xl p-6">
                <CardTitle className="text-3xl font-bold">Simulador e Projeção de NPS</CardTitle>
                <CardDescription className="text-red-100 text-lg">
                  Ferramenta interativa para simular cenários e calcular metas de NPS.
                </CardDescription>
              </CardHeader>
              <CardContent className="p-6">
                <Tabs defaultValue="projection">
                  <TabsList className="grid w-full grid-cols-2">
                    <TabsTrigger value="projection">Projeção de NPS</TabsTrigger>
                    <TabsTrigger value="inverse">Cálculo Inverso (Meta NPS 95)</TabsTrigger>
                  </TabsList>
                  <TabsContent value="projection" className="mt-4">
                    <h3 className="text-2xl font-semibold mb-4 text-gray-800">Projeção de NPS CX Consolidado</h3>
                    <p className="text-gray-600 mb-6">
                      Ajuste os volumes de promotores, detratores e neutros para a visão consolidada de todos os canais e veja a projeção do NPS CX.
                    </p>
                    <div className="overflow-x-auto mb-6">
                      <table className="w-full text-left border-collapse">
                        <thead>
                          <tr className="bg-red-700 text-white">
                            <th className="p-3 border-r">Mês</th>
                            <th className="p-3 border-r">Status</th>
                            <th className="p-3">Promotores</th>
                            <th className="p-3">Neutros</th>
                            <th className="p-3">Detratores</th>
                            <th className="p-3">Vol. Total</th>
                            <th className="p-3">NPS CX</th>
                          </tr>
                        </thead>
                        <tbody>
                          {npsProjectionData.map((monthData, index) => (
                            <tr key={index} className={`border-b ${monthData.isProjected ? 'bg-red-50' : 'hover:bg-gray-50'}`}>
                              <td className="p-3 font-medium border-r">{monthData.month}</td>
                              <td className="p-3 border-r text-sm text-center">
                                <span className={`px-2 py-1 rounded-full text-white ${monthData.isProjected ? 'bg-blue-500' : 'bg-green-600'}`}>
                                  {monthData.isProjected ? 'Projetado' : 'Fechado'}
                                </span>
                              </td>
                              <td className="p-3">
                                <Input
                                  type="number"
                                  value={monthData.prom}
                                  onChange={(e) => handleProjectionChange(index, 'prom', e.target.value)}
                                  className="w-full text-center"
                                />
                              </td>
                              <td className="p-3">
                                <Input
                                  type="number"
                                  value={monthData.neutr}
                                  onChange={(e) => handleProjectionChange(index, 'neutr', e.target.value)}
                                  className="w-full text-center"
                                />
                              </td>
                              <td className="p-3">
                                <Input
                                  type="number"
                                  value={monthData.detra}
                                  onChange={(e) => handleProjectionChange(index, 'detra', e.target.value)}
                                  className="w-full text-center"
                                />
                              </td>
                              <td className="p-3 font-bold text-gray-600 text-center">{monthData.totalVolume}</td>
                              <td className="p-3 font-bold text-red-800 text-center">{monthData.npsCx}%</td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                    
                    <Card className="bg-blue-50 border-blue-200 mt-8">
                      <CardHeader>
                        <CardTitle className="text-xl">Análise de Meta Anual (NPS 95)</CardTitle>
                        <CardDescription>
                          Com base no volume projetado, veja a distribuição necessária para atingir a meta de NPS 95 para o ano.
                        </CardDescription>
                      </CardHeader>
                      <CardContent>
                         <div className="flex items-end space-x-4 mb-4">
                          <div className="flex-grow">
                            <Label htmlFor="projected-total-notes" className="text-base">Volume de Notas Projetado por Mês</Label>
                            <Input
                              id="projected-total-notes"
                              type="number"
                              value={projectedTotalNotes}
                              onChange={(e) => setProjectedTotalNotes(parseInt(e.target.value, 10) || 0)}
                              className="mt-2 text-center"
                            />
                          </div>
                          <Button onClick={handleAnnualGoalCalculation} className="bg-blue-600 hover:bg-blue-700 text-white shadow-lg">
                            Calcular Meta Anual
                          </Button>
                        </div>
                        {annualGoalResult && (
                          <div className="mt-4">
                            <p className="text-lg font-semibold">Resumo do Ano:</p>
                            <ul className="list-disc list-inside space-y-1 mt-2 text-gray-700">
                              <li>NPS Acumulado até Julho: <span className="font-bold text-blue-800">{annualGoalResult.currentNps}%</span></li>
                              <li>Volume Total Anual Projetado: <span className="font-bold">{annualGoalResult.projectedTotalAnnualVolume}</span> notas</li>
                            </ul>
                            {annualGoalResult.isAchievable ? (
                              <div className="mt-4 p-4 rounded-lg bg-green-100 text-green-800 border border-green-300">
                                <p className="font-bold text-xl">A meta anual de NPS 95% é alcançável!</p>
                                <p className="mt-2">Para alcançar a meta, a distribuição mensal necessária para os próximos 5 meses é:</p>
                                <ul className="mt-2 list-disc list-inside font-medium">
                                  <li>Promotores por Mês: <span className="font-bold text-green-900">{annualGoalResult.monthlyPromoters}</span></li>
                                  <li>Neutros por Mês: <span className="font-bold text-green-900">{annualGoalResult.monthlyNeutrals}</span></li>
                                  <li>Detratores por Mês: <span className="font-bold text-green-900">{annualGoalResult.monthlyDetractors}</span></li>
                                </ul>
                              </div>
                            ) : (
                              <div className="mt-4 p-4 rounded-lg bg-red-100 text-red-800 border border-red-300">
                                <p className="font-bold text-xl">Aviso: A meta anual de NPS 95% é inatingível.</p>
                                <p className="mt-2">O NPS máximo que você pode atingir com o volume de notas projetado é: <span className="font-bold text-red-900">{annualGoalResult.maxNps}%</span>.</p>
                              </div>
                            )}
                          </div>
                        )}
                      </CardContent>
                    </Card>
                    
                    <Card className="bg-red-50 border-red-200 mt-8">
                      <CardHeader>
                        <CardTitle className="text-xl">Gráfico de Projeção do NPS CX</CardTitle>
                      </CardHeader>
                      <CardContent>
                        <ResponsiveContainer width="100%" height={300}>
                          <LineChart data={npsProjectionData} margin={{ top: 5, right: 20, left: -20, bottom: 5 }}>
                            <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                            <XAxis dataKey="month" />
                            <YAxis domain={[0, 100]} />
                            <Tooltip />
                            <Legend />
                            <Line type="monotone" dataKey="npsCx" name="NPS CX Projetado" stroke="#a51f38" strokeWidth={2} activeDot={{ r: 8 }} animationDuration={1500} />
                          </LineChart>
                        </ResponsiveContainer>
                        <div className="mt-4 text-center">
                          <p className="text-xl font-bold text-gray-800">
                            NPS CX Final Projetado: <span className="text-red-800">{npsProjectionData[npsProjectionData.length - 1]?.npsCx}%</span>
                          </p>
                        </div>
                      </CardContent>
                    </Card>
                  </TabsContent>
                  <TabsContent value="inverse" className="mt-4">
                    <h3 className="text-2xl font-semibold mb-4 text-gray-800">Cálculo Inverso (Meta de NPS 95)</h3>
                    <p className="text-gray-600 mb-6">
                      Informe o volume total de notas que você espera obter por mês para ver a distribuição necessária para alcançar um NPS de 95.
                    </p>
                    <div className="flex items-end space-x-4 mb-6 p-4 bg-gray-50 border rounded-lg">
                      <div className="flex-grow">
                        <Label htmlFor="total-notas" className="text-base">Volume Total de Notas por Mês</Label>
                        <Input
                          id="total-notas"
                          type="number"
                          value={totalNotas}
                          onChange={(e) => setTotalNotas(parseInt(e.target.value, 10) || 0)}
                          className="mt-2 text-center"
                        />
                      </div>
                      <Button onClick={handleInverseCalculation} className="bg-green-600 hover:bg-green-700 text-white shadow-lg">
                        Calcular Meta Mensal
                      </Button>
                    </div>
                    {inverseResults.length > 0 && (
                      <Card className="bg-green-50 border-green-200">
                        <CardHeader>
                          <CardTitle className="text-xl">Resultados para a Meta de NPS 95</CardTitle>
                          <CardDescription>
                            A meta é um NPS de 95. Os valores abaixo indicam a distribuição necessária de feedback.
                          </CardDescription>
                        </CardHeader>
                        <CardContent>
                          <div className="overflow-x-auto">
                            <table className="w-full text-left border-collapse">
                              <thead>
                                <tr className="bg-green-500 text-white">
                                  <th className="p-3">Mês</th>
                                  <th className="p-3">Total Notas</th>
                                  <th className="p-3">Promotores</th>
                                  <th className="p-3">Detratores</th>
                                  <th className="p-3">Neutros</th>
                                  <th className="p-3">NPS Calculado</th>
                                </tr>
                              </thead>
                              <tbody>
                                {inverseResults.map((result, index) => (
                                  <tr key={index} className="border-b hover:bg-green-100">
                                    <td className="p-3 font-medium">{result.month}</td>
                                    <td className="p-3">{result.totalNotas}</td>
                                    <td className="p-3">{result.promotores}</td>
                                    <td className="p-3">{result.detratores}</td>
                                    <td className="p-3">{result.neutros}</td>
                                    <td className="p-3 font-bold">{result.npsCalculado}%</td>
                                  </tr>
                                ))}
                              </tbody>
                            </table>
                          </div>
                        </CardContent>
                      </Card>
                    )}
                  </TabsContent>
                </Tabs>
              </CardContent>
            </Card>
          </div>
        );
      };

      const rootElement = document.getElementById('root');
      const root = ReactDOM.createRoot(rootElement);
      root.render(<App />);
    };
  </script>
</body>
</html>
